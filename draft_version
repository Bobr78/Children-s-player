# Надо переделать - в форме оставляем только визуализацию, логику переключения выносим в управляющий цикл

import wx								#используем для проприсовки фрейма
import imageio 								#используем для заполнения карты событий
import io
import chardet
import os
import codecs


class Form_player(wx.Frame):

# долго думал и решил что в папке есть файл ini_Form.txt
# в которым сохраняем список ключей - просто передавать их при инициализации долшо и чревато ошибками. 
# при выборе нового скрина - передаем при формировании класса название ini файла в котором прописываем параметры
# ключи: R, G, B- цвет маски, IMAGE_PATH_M-файл карты событий.png, IMAGE_PATH_BG-фон, IMAGE_PATH_B-кнопки
# B*_Width, B*_Height - параметры кнопки * (кнопки считаем с лева направо и с верху вниз)
# Shift*_ - параметры сдвигаемой кнопки - ПОКА КНОПКИ СДВИГАЮТСЯ ТОЛЬКО ПО ГОРИЗОНТАЛИ!!!! от MIN до MAX


# ПРАВИЛА ДЛЯ ФОРМИРОВАНИЯ КАРТЫ СОБЫТИЙ (event_map) - цвет в канале R !!!
# 0 значение по умолчанию, НЕ ИСПОЛЬЗОВАТЬ В КАРТЕ СОБЫТИЙ!!
# значения с 1 по 255 - любые, привязка событий в управляющем классе


#______________________Инициация переменных класса

    def __init__(self):
        wx.Frame.__init__(self, None, -1, "Shaped Window", style = wx.FRAME_SHAPED | wx.SIMPLE_BORDER )
        
#=========================== работает ===============================================================================================
#прикрутить передачу инициирующего файла и если нет то по умолчанию брать q.txt
	filename = 'q.txt'
	__location__ = os.path.realpath(os.path.join(os.getcwd(), os.path.dirname(__file__))) 

# конструкция os.path.join(__location__, filename) и переменная __location__ 
# позволяет читать файл из текущего катклога
# https://qastack.ru/programming/4060221/how-to-reliably-open-a-file-in-the-same-directory-as-a-python-script
# bytes и т.д. перекодирует файл чтобы небыло всяких маркеров типа BOM символа



	bytes = min(32, os.path.getsize(os.path.join(__location__, filename)))
	raw = open(os.path.join(__location__, filename), 'rb').read(bytes)

	if raw.startswith(codecs.BOM_UTF8):
	    encoding = 'utf-8-sig'
	else:
	    result = chardet.detect(raw)
	    encoding = result['encoding']

	with open(os.path.join(__location__, filename), 'r', encoding=encoding) as file:								#Читаем файл
		lines = file.read().split()	#не читаем комментарии (начинаются с символа #)
	print(lines)
	dic = {}								# Создаем пустой словарь

	for line in lines:							# Проходимся по каждой строчке
			if line[0]!='#':
				key,value = line.split(':')					# Разделяем каждую строку по двоеточию
				dic.update({key:value})
#======================================================================================================================================

        self.EVENT_Form_player={}						# словарь переменных для отслеживания изменений параметров кнопок


#______________________Делаем форму окна в виде картинки

	self.hasShape = False
        self.delta = wx.Point(0,0)
	self.bmp = wx.Image(self.dic[IMAGE_PATH_BG], wx.BITMAP_TYPE_ANY).ConvertToBitmap()			#загружаем полностью картинку
	self.transparentColour = wx.Colour(self.dic[R], self.dic[G], self.dic[B], alpha=wx.ALPHA_OPAQUE)                           
        self.SetClientSize((self.bmp.GetWidth(), self.bmp.GetHeight()))

        dc = wx.ClientDC(self)  									
        dc.DrawBitmap(self.bmp, 0,0, True) 								# рисует картинку в окне. ВАЖНО! если перехватываем событие wx.EVT_PAINT то 															# используем wx.PaintDC(self) в других случаях wx.ClientDC(self)
												# http://python-lab.blogspot.com/2012/10/wxpython-in-action-12.html

#______________________Загружаем карту событий

        self.event_map = imageio.imread(self.dic[IMAGE_PATH_M], pilmode='R')					#запись картинки для карты событий по каналу R


#______________________Инициируем Скин 
	self.bmp_B = wx.Image(self.dic[IMAGE_PATH_B], wx.BITMAP_TYPE_ANY).ConvertToBitmap()		#загружаем картинку с кнопками
	self.DC_B=wx.MemoryDC()										#выделяем холст в памяти
	self.DC_B.SelectObject(wx.Bitmap(self.bmp_B.GetWidth(), self.bmp_B.GetHeight()))		#связываем холст с размерами
	self.DC_B.DrawBitmap(self.bmp_B, 0,0, False)							#рисуем картинку кнопки на холст в памяти
													
					#рисуем картинку на экране вызовом
					#КУДА.Blit(в_какое_место_xdest, в_какое_место_ydest, width_картинки, 
					#height_картинки, откуда_source=self.DC_B1, смещение_в_self.DC_B1_xsrc,
					#смещение_в_self.DC_B1_ysrc, logicalFunc=wx.COPY, #useMask=False,
					#чтото_про_маску_xsrcMask=-1, ysrcMask=-1)

	self.bmp_Mem = wx.Image(self.dic[IMAGE_PATH_Mem], wx.BITMAP_TYPE_ANY).ConvertToBitmap()	#загружаем картинку
	self.DC_Mem=wx.MemoryDC()									#выделяем холст в памяти
	self.DC_Mem.SelectObject(wx.Bitmap(self.bmp_Mem.GetWidth(), self.bmp_Mem.GetHeight()))		#связываем холст с размерами
	self.DC_Mem.DrawBitmap(self.bmp_Mem, 0,0, False)							#рисуем картинку на холст в памяти
	

#______________________связываем события формы с функциями
	
        self.SetWindowShape()
        self.Bind(wx.EVT_LEFT_DCLICK, self.OnDoubleClick)
        self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)
        self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
        self.Bind(wx.EVT_MOTION, self.OnMouseMove)
        self.Bind(wx.EVT_RIGHT_UP, self.OnExit)
        self.Bind(wx.EVT_PAINT, self.OnPaint)
        self.Bind(wx.EVT_WINDOW_CREATE, self.SetWindowShape)

#_____________________________________________________________________________методы класса_____________________________________________________________________________________

    def Line_Light(self,percent)	#заполняем линию загрузки/воспроиведения
	pass


#_______________________________________________метод вызова класса как функции

    def __call__(self):										#  !!!!!!!!пока криво надо делать через генерацию событий !!!!!! 
	return(self.EVENT_Form_player)
#______________________________________________метод рисования окна												
    def SetWindowShape(self, evt=None):
        r = wx.Region(self.bmp , self.transparentColour)
        self.hasShape = self.SetShape(r)

#_______________________________________________метод при двойном щелчке мышкой
    def OnDoubleClick(self, evt):
        pass

#_________________________________________________перерисовка окна
    def OnPaint(self, evt):
        dc = wx.PaintDC(self)
        dc.DrawBitmap(self.bmp, 0, 0, True)

#________________________________________________закрытие окна
    def OnExit(self, evt):
        self.Close()


#____________________________________________метод при перемещении мыши
    def OnMouseMove(self, evt):
        if evt.Dragging() and evt.LeftIsDown():
            pos = self.ClientToScreen(evt.GetPosition())
            newPos = (pos.x - self.delta.x, pos.y - self.delta.y)
            self.Move(newPos)
	

#_______________________________________________изменение движка Shift -  !!! ПРИКРУТИЛ ПЕРЕМЕЩЕНИЕ К ПЕРЕМЕЩЕНИЮ МЫШИ !!!____________________________________________________________
	
	absol=(wx.Point(self.ClientToScreen(evt.GetPosition()).x - self.GetPosition().x, self.ClientToScreen(evt.GetPosition()).y - self.GetPosition().y))
	self.EVENT_Form_player.update({X2,absol.x-1})
	self.EVENT_Form_player.update({Y2,absol.y-1})

	if self.EVENT_Form_player[Flag]==self.dic[Shift1_Key]:

		#считаем что перемещение только по X
		self.EVENT_Form_player[Y2]=self.dic[Shift1_Ymin] # в nin файле Shift1_Ymin=Shift1_Ymax
		#нормируем граници перемещения по X

		#щелчок мыши может быть на крае движка с лева(меньше меньшего), поэтому ограничиваем минимум
		if self.EVENT_Form_player[X1]<self.dic[Shift1_Xmin]:self.EVENT_Form_player[X1]=self.dic[Shift1_Xmin]	#возможно X1 и нафиг не нужен
		if self.EVENT_Form_player[X1]>self.dic[Shift1_Xmax]:self.EVENT_Form_player[X1]=self.dic[Shift1_Xmax]	#возможно X1 и нафиг не нужен

		if self.EVENT_Form_player[X2]<self.dic[Shift1_Xmin]:self.EVENT_Form_player[X2]=self.dic[Shift1_Xmin]
		if self.EVENT_Form_player[X2]>self.dic[Shift1_Xmax]:self.EVENT_Form_player[X2]=self.dic[Shift1_Xmax]


		#  Shift_XScreen, Shift_YScreen - кооринаты отображения движка в памяти которая потом будет блинкать на экран. (попробовать блинкать внутри памяти чтобы не плодить холсты в памяти)   		# рисуем часть экрана 
		DC_B.Blit(self.dic[Shift1_XScreen], self.dic[Shift1_YScreen], self.dic[Shift1_Width], self.dic[Shift1_Height], self.DC_Mem, self.dic[Shift1_XMem], self.dic[Shift1_YMem], logicalFunc=wx.COPY)
 		# рисуем движок на части экрана
		DC_B.Blit(self.dic[Shift1_XScreen_Pull], self.dic[Shift1_YScreen_Pull], self.dic[Shift1_Width_Pull], self.dic[Shift1_Height_Pull], self.DC_Mem, self.EVENT_Form_player[X2], self.EVENT_Form_player[Y2], logicalFunc=wx.COPY)
		# перемещение части экрана с движком на рабочий экран
		dc.Blit(self.dic[Shift1_XMem], self.dic[Shift1_YMem], self.dic[Shift1_Width], self.dic[Shift1_Height], self.DC_B, self.dic[Shift1_X], self.dic[Shift1_Y], logicalFunc=wx.COPY)
#_________________________________________________________________________________________________________________________________________________________________________________________



		
#____________________________________________метод при отпускании левой клавиши мыши
        
    def OnLeftUp(self, evt):
        if self.HasCapture(): 
            self.ReleaseMouse()

	#__ сохраняем событие и координаты - возможно нафиг не надо
#	absol=(wx.Point(self.ClientToScreen(evt.GetPosition()).x - self.GetPosition().x, self.ClientToScreen(evt.GetPosition()).y - self.GetPosition().y))
#	self.EVENT_Form_player.update({X2,absol.x-1})
#	self.EVENT_Form_player.update({Y2,absol.y-1})
	
	dc = wx.ClientDC(self)
	
	if self.EVENT_Form_player[Flag]==self.dic[Shift1_Key]:		#сброс флага чтобы не отслеживалось перемещение и возврат 
		self.EVENT_Form_player[Flag]=0
		return

	#изменение кнопки B1 при нажатии
	if self.EVENT_Form_player[Flag]==self.dic[B1_Key]: 
		if self.EVENT_Form_player.get[B1_Key,0]:	#кнопка нажата из состояния ON, то есть кнопка ранее нажималась и флаг равен 1		
			dc.Blit(self.dic[B1_XScreen], self.dic[B1_YScreen], self.dic[B1_Width], self.dic[B1_Height], self.DC_B, self.dic[B1_XMem_OFF], self.dic[B1_YMem_OFF], logicalFunc=wx.COPY)
			self.EVENT_Form_player.get[B1_Key]=0
		else:						#кнопка нажата из состояния OFF, то есть кнопка ранее не нажималась и флаг равен 0 (по умолчанию - значение указано в .get)		
			dc.Blit(self.dic[B1_XScreen], self.dic[B1_YScreen], self.dic[B1_Width], self.dic[B1_Height], self.DC_B, self.dic[B1_XMem_ON], self.dic[B1_YMem_ON], logicalFunc=wx.COPY)
			self.EVENT_Form_player.get[B1_Key]=1


	#изменение кнопки B2 при нажатии
	if self.EVENT_Form_player[Flag]==self.dic[B2_Key]: 
		if self.EVENT_Form_player.get[B2_Key,0]:	#кнопка нажата из состояния ON, то есть кнопка ранее нажималась и флаг равен 1		
			dc.Blit(self.dic[B2_XScreen], self.dic[B2_YScreen], self.dic[B2_Width], self.dic[B2_Height], self.DC_B, self.dic[B2_XMem_OFF], self.dic[B2_YMem_OFF], logicalFunc=wx.COPY)
			self.EVENT_Form_player.get[B2_Key]=0
		else:						#кнопка нажата из состояния OFF, то есть кнопка ранее не нажималась и флаг равен 0 (по умолчанию - значение указано в .get)		
			dc.Blit(self.dic[B2_XScreen], self.dic[B2_YScreen], self.dic[B2_Width], self.dic[B12_Height], self.DC_B, self.dic[B2_XMem_ON], self.dic[B2_YMem_ON], logicalFunc=wx.COPY)
			self.EVENT_Form_player.get[B2_Key]=1
	

	#изменение кнопки B3 при нажатии
	if self.EVENT_Form_player[Flag]==self.dic[B3_Key]: 
		if self.EVENT_Form_player.get[B3_Key,0]:	#кнопка нажата из состояния ON, то есть кнопка ранее нажималась и флаг равен 1		
			dc.Blit(self.dic[B3_XScreen], self.dic[B3_YScreen], self.dic[B3_Width], self.dic[B3_Height], self.DC_B, self.dic[B3_XMem_OFF], self.dic[B3_YMem_OFF], logicalFunc=wx.COPY)
			self.EVENT_Form_player.get[B3_Key]=0
		else:						#кнопка нажата из состояния OFF, то есть кнопка ранее не нажималась и флаг равен 0 (по умолчанию - значение указано в .get)		
			dc.Blit(self.dic[B3_XScreen], self.dic[B3_YScreen], self.dic[B3_Width], self.dic[B3_Height], self.DC_B, self.dic[B3_XMem_ON], self.dic[B3_YMem_ON], logicalFunc=wx.COPY)
			self.EVENT_Form_player.get[B3_Key]=1


	#изменение кнопки B4 при нажатии
	if self.EVENT_Form_player[Flag]==self.dic[B4_Key]: 
		if self.EVENT_Form_player.get[B4_Key,0]:	#кнопка нажата из состояния ON, то есть кнопка ранее нажималась и флаг равен 1		
			dc.Blit(self.dic[B4_XScreen], self.dic[B4_YScreen], self.dic[B4_Width], self.dic[B4_Height], self.DC_B, self.dic[B4_XMem_OFF], self.dic[B4_YMem_OFF], logicalFunc=wx.COPY)
			self.EVENT_Form_player.get[B4_Key]=0
		else:						#кнопка нажата из состояния OFF, то есть кнопка ранее не нажималась и флаг равен 0 (по умолчанию - значение указано в .get)		
			dc.Blit(self.dic[B4_XScreen], self.dic[B4_YScreen], self.dic[B4_Width], self.dic[B4_Height], self.DC_B, self.dic[B4_XMem_ON], self.dic[B4_YMem_ON], logicalFunc=wx.COPY)
			self.EVENT_Form_player.get[B4_Key]=1


#____________________________________________метод при нажатии левой клавиши мыши

    def OnLeftDown(self, evt):									
        self.CaptureMouse()

	#__ сохраняем событие и координаты
	absol=(wx.Point(self.ClientToScreen(evt.GetPosition()).x - self.GetPosition().x, self.ClientToScreen(evt.GetPosition()).y - self.GetPosition().y))
	self.EVENT_Form_player.update({X1,absol.x-1})
	self.EVENT_Form_player.update({Y1,absol.y-1})
	self.EVENT_Form_player.update({Flag,self.event_map[absol.y-1,absol.x-1]})	#для удобства назначаем флаг а не определяем его каждый раз (да и быстрее будет)

#____________________________________________перерисовка кнопок которые двигаются и оставлют после себя "шлейф"

    def ButtonPaint(self, addr_button, x_button, y_button):	
	pass
	# как то меняем изображение кнопок например так:
	# button.bmp = wx.Image(addr_button, wx.BITMAP_TYPE_ANY).ConvertToBitmap()
	# dc = wx.PaintDC(self)
	# dc.DrawBitmap(button.bmp, x_button, y_button, True)



#Для управления - Form_player
#app = wx.App()
#Form_player().Show()
#app.MainLoop()

